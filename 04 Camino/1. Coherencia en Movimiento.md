# Coherencia en Movimiento

### Cómo avanzar rápido sin perder forma

---

## Introducción

Uno de los primeros choques al trabajar con IA en modo *vibe coding* no es técnico, sino **estético y estructural**.

La IA es rápida, creativa y sorprendentemente competente. Pero si se la deja avanzar sin referencias fuertes, el resultado suele ser un sistema que:

* funciona,  
* crece,  
* pero **no se siente coherente**.

Pantallas similares con comportamientos distintos. Flujos de navegación inconsistentes. Estructuras de proyecto que se parecen… pero no encajan del todo.

Este documento parte de una premisa clara:

**La velocidad sin coherencia no es progreso, es dispersión.**

El objetivo de este primer capítulo del *Camino* es responder a una pregunta concreta:

¿Cómo mantener una coherencia visual, estructural y de comportamiento mientras avanzamos rápido en una fase exploratoria asistida por IA?

No desde el control rígido. No desde la reutilización forzada. Sino desde referencias vivas que orienten el movimiento.

---

## 1\. El falso dilema: velocidad o coherencia

En los modelos tradicionales de desarrollo, la coherencia se consigue mediante:

* abstracciones compartidas,  
* componentes reutilizables,  
* arquitecturas rígidas,  
* revisiones humanas constantes.

Todo esto tiene un coste alto, pero era necesario porque **escribir código distinto era caro**.

En un modelo IA-first, esta ecuación cambia radicalmente:

* escribir código nuevo es barato,  
* copiar y adaptar es trivial,  
* regenerar es posible.

El resultado es un falso dilema muy común:

* o dejamos a la IA crear libremente (velocidad),  
* o la encorsetamos con componentes y reglas (coherencia).

Este documento sostiene que **ese dilema es falso**.

La coherencia no tiene por qué venir de la reutilización literal de código.

---

## 2\. La coherencia no es igualdad

Antes de avanzar, conviene aclarar un malentendido frecuente.

**Coherencia no significa que todo sea igual.**

Significa que:

* las decisiones se repiten de forma reconocible,  
* los patrones son identificables,  
* el sistema “rima consigo mismo”.

Dos pantallas pueden:

* usar componentes distintos,  
* tener layouts distintos,  
* resolver problemas distintos,

y aun así sentirse parte del mismo sistema.

La coherencia es una propiedad **perceptiva y estructural**, no un efecto secundario del DRY.

---

## 3\. El problema del componente compartido en la era IA

La solución tradicional a la coherencia ha sido:

“Si todo usa el mismo componente, todo será coherente.”

En la práctica, esto suele derivar en:

* componentes hipertrofiados,  
* APIs enormes,  
* flags por todas partes,  
* miedo a tocar nada.

En un contexto de desarrollo regenerativo, este enfoque introduce un nuevo problema:

**La coherencia se paga con pérdida de libertad exploratoria.**

Además, va en contra de una de las grandes fortalezas de la IA:

* generar código específico,  
* adaptado al contexto,  
* sin miedo a duplicar.

Por eso, en este modelo, **la coherencia no se persigue en runtime**, sino **en generation time**.

---

## 4\. Coherencia por referencia, no por abstracción

El principio clave de este documento es el siguiente:

**La IA mantiene mejor la coherencia cuando imita buenos ejemplos que cuando obedece abstracciones genéricas.**

Esto nos lleva a un cambio de enfoque:

* de componentes compartidos → a **implementaciones de referencia**  
    
* de reutilización → a **inspiración estructurada**

---

## 5\. Implementaciones de referencia

Una implementación de referencia no es:

* una librería,  
* un componente base,  
* una abstracción reutilizable.

Es simplemente:

**Código real, concreto, bien resuelto, que sirve como ancla de coherencia.**

Por ejemplo:

* una página maestro–detalle bien diseñada,  
* una lista con filtros y acciones claras,  
* un flujo de creación–edición coherente.

Estas implementaciones:

* no se importan,  
* no se heredan en runtime,  
* no se configuran.

Se **copian, adaptan y regeneran**.

La IA es excepcionalmente buena haciendo esto.

---

## 6\. Artefactos de Referencia: coherencia sin jaulas

Para que este enfoque escale, las implementaciones de referencia no deben ser archivos sueltos, sino **un sistema reconocible**.

Aquí aparece el concepto de **Artefactos de Referencia**:
    
Un Artefacto de Referencia es un conjunto de:

* una implementación de referencia,  
* sus especificaciones asociadas,  
* sus flujos de uso,  
* sus invariantes explícitas.

No define “cómo debe verse todo”, define **qué significa resolver bien un tipo de problema**.

Ejemplos:

* “Gestión de entidades con listado \+ detalle”  
* “Flujo CRUD con riesgo de pérdida de datos”  
* “Pantalla de exploración con filtros progresivos”

Estos artefactos actúan como:

* puntos de orientación,  
* referencias culturales del proyecto,  
* fuentes de coherencia implícita.

---

## 7\. Coherencia durante la exploración

En la fase exploratoria:

* el código es efímero,  
* las decisiones se prueban,  
* muchas cosas se descartan.

Pretender una coherencia perfecta en esta fase es contraproducente.

Pero sí es posible mantener una **coherencia suficiente** si:

* toda nueva funcionalidad parte de una referencia clara,  
* la IA recibe ejemplos explícitos del “estilo del sistema”,  
* se evita inventar patrones nuevos innecesariamente.

La regla práctica es simple:

**Explora libremente, pero siempre desde algo reconocible.**

---

## 8\. Qué decisiones deben ser coherentes (y cuáles no)

No todo necesita coherencia estricta.

Este modelo propone distinguir entre:

### Decisiones que **sí** deben ser coherentes

* estructura de navegación,  
* tipos de flujos (crear, editar, borrar),  
* jerarquía visual,  
* estados (loading, error, vacío),  
* organización del proyecto.

### Decisiones que **pueden variar**

* detalles visuales menores,  
* microinteracciones,  
* copy no crítico,  
* orden interno de campos.

La coherencia se protege en lo **estructural**, no en lo decorativo.

---

## 9\. Coherencia como propiedad emergente

Una consecuencia importante de este enfoque es que:

La coherencia no se diseña una vez, **emerge del uso continuado de buenas referencias.**

Si:

* los Artefactos de Referencia están bien elegidos,  
* las implementaciones de referencia se actualizan,  
* la IA se guía por ellas,

entonces el sistema tiende a **alinearse consigo mismo**.

No porque esté forzado, sino porque el camino está bien marcado.

---

## 10\. Riesgos y señales de alarma

Este enfoque no es inmune a problemas.

Algunas señales de alarma claras:

* proliferación excesiva de patrones,  
* referencias contradictorias,  
* artefactos que intentan cubrir demasiados casos,  
* pérdida de una “forma reconocible”.

Cuando eso ocurre, la solución no es añadir reglas, sino **reducir referencias**.

Menos caminos, mejor señalizados.

---

## 11\. Cierre: avanzar sin perder forma

Este primer documento del *Camino* establece una idea fundamental:

**La coherencia en un sistema regenerativo no se impone, se cultiva mediante referencias vivas.**

No se trata de frenar a la IA. Se trata de darle un terreno con forma.

En los siguientes capítulos profundizaremos en:

* cómo especificar sin sobredeterminar,  
* cómo regenerar sin destruir,  
* cómo hacer que exploración y fundación se refuercen.

Pero todo empieza aquí:

**Avanzar rápido, sí. Avanzar a ciegas, no.**

