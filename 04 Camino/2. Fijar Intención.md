# Fijar Intención

### Cómo repetir sin congelar, cómo guiar sin asfixiar

---

## Introducción

Una de las promesas más atractivas del desarrollo asistido por IA es la velocidad. Una de sus mayores amenazas es el **no-determinismo**.

Ante una misma intención, la IA puede:

* producir soluciones distintas,  
* tomar decisiones implícitas diferentes,  
* introducir variaciones sutiles que, acumuladas, erosionan la coherencia.

Esto no es un bug. Es una característica inherente a los modelos generativos.

El problema no es que la IA sea no determinista. El problema es **no saber cuándo ese no-determinismo es deseable y cuándo es peligroso**.

Este documento responde a una pregunta central del *Camino*:

¿Cómo escribir especificaciones que permitan generar y regenerar una funcionalidad de forma **pseudo-determinista**, sin matar la creatividad ni sobredeterminar la UI?

---

## 1\. El error clásico: especificar más para controlar más

La reacción instintiva ante el no-determinismo suele ser:

“Si la IA no hace siempre lo mismo, voy a especificar absolutamente todo.”

El resultado habitual:

* especificaciones largas,  
* llenas de detalles visuales,  
* difíciles de mantener,  
* rápidamente obsoletas.

Y lo peor:

* **siguen sin garantizar el mismo resultado**.

Porque el problema no es la falta de detalle, sino **qué tipo de decisiones dejamos abiertas**.

---

## 2\. Determinismo humano vs pseudo-determinismo IA

En el desarrollo tradicional:

* el determinismo viene del compilador,  
* el mismo código produce el mismo resultado.

En el desarrollo regenerativo:

* el resultado es una síntesis,  
* basada en contexto,  
* referencias,  
* y probabilidad.

Por eso el objetivo realista no es el determinismo absoluto, sino:

**Pseudo-determinismo intencional**

Resultados suficientemente similares porque el espacio de decisión ha sido acotado.

Las especificaciones no fuerzan el resultado. **Reducen el espacio de variación**.

---

## 3\. Qué es realmente una especificación en este modelo

En este modelo, una especificación **no es**:

* una descripción exhaustiva,  
* un contrato legal,  
* una receta paso a paso.

Una especificación es:

**Un artefacto que fija intención, límites y prioridades.**

Su función principal no es describir cómo debe verse algo, sino **qué decisiones no deberían volver a tomarse**.

---

## 4\. Especificar decisiones, no resultados

La clave para limitar el no-determinismo está aquí:

**Especificar decisiones estructurales, no resultados superficiales.**

Comparémoslo:

❌ Especificación débil (aparente detalle)

* “El botón debe ser azul y estar a la derecha.”

✅ Especificación fuerte (decisión)

* “Existe una acción primaria claramente destacada para la creación de nuevas entidades.”

La segunda:

* deja libertad visual,  
* pero elimina ambigüedad funcional.

---

## 5\. Capas de especificación

Para que las especificaciones sean útiles y sostenibles, conviene pensar en **capas**, no en documentos monolíticos.

Este modelo distingue al menos cuatro:

### 1\. Especificaciones estructurales

* tipo de pantalla (listado, detalle, wizard),  
* jerarquía de zonas,  
* relación entre vistas.

Son las más importantes para la coherencia.

---

### 2\. Especificaciones de comportamiento

* flujos de creación, edición, borrado,  
* estados (loading, error, vacío),  
* dependencias entre acciones.

Aquí se decide “cómo se usa” la funcionalidad.

---

### 3\. Especificaciones de dominio

* datos relevantes,  
* reglas de negocio,  
* restricciones semánticas.

Estas reducen enormemente el espacio de invención errónea de la IA.

---

### 4\. Especificaciones de intención UX

* qué debe sentirse claro,  
* qué debe ser difícil o peligroso,  
* qué requiere confirmación.

No hablan de UI, hablan de experiencia.

---

## 6\. Qué NO debe especificarse

Una especificación eficaz **omite activamente** ciertas cosas.

Generalmente no conviene fijar:

* colores,  
* tamaños,  
* márgenes,  
* componentes concretos,  
* microinteracciones no críticas.

No porque no importen, sino porque **ya están implícitas en las referencias** (Artefactos de Referencia, implementaciones previas, sistema visual).

Especificarlas explícitamente introduce rigidez innecesaria.

---

## 7\. Especificaciones heredadas y adaptadas

Una de las ideas clave del modelo es que:

**Una nueva especificación no nace de cero.**

Cuando una funcionalidad se basa en un patrón existente:

* hereda parte de su especificación,  
* la adapta a su contexto,  
* y la concreta donde es necesario.

Esto genera una **cadena de intención**:

* patrón → instancia → variación.

La especificación de la instancia:

* no repite todo,  
* resume lo relevante,  
* y explicita solo las diferencias.

---

## 8\. Especificaciones como memoria del sistema

En un sistema regenerativo, el mayor enemigo es la pérdida de contexto.

Las especificaciones cumplen aquí un papel crucial:

**Son la memoria persistente de las decisiones.**

Cuando dentro de seis meses alguien (humano o IA) se pregunte:

* “¿por qué esto funciona así?”  
* “¿es un bug o una decisión?”

La respuesta no debería estar:

* solo en el código,  
* solo en la cabeza de alguien,  
* solo en un PR antiguo.

Debería estar en la especificación.

---

## 9\. Relación entre especificación y código

En este modelo:

* el código es la **manifestación actual**,  
* la especificación es la **intención estable**.

Ninguna es absoluta:

* el código puede desviarse,  
* la especificación puede quedarse corta.

Pero juntas permiten:

* detectar deriva,  
* regenerar con sentido,  
* refactorizar sin reimaginarlo todo.

---

## 10\. Señales de una mala especificación

Algunas señales claras de que una especificación no está cumpliendo su función:

* es más larga que el código que describe,  
* repite obviedades,  
* describe UI pixel a pixel,  
* no ayuda a decidir,  
* no se consulta al regenerar.

Una buena especificación:

* se puede releer rápido,  
* aclara dudas reales,  
* reduce discusiones,  
* guía a la IA sin dictarle cada línea.

---

## 11\. Cierre: acotar para crear mejor

Limitar el no-determinismo no es un acto de control, sino de **responsabilidad arquitectónica**.

En un sistema donde generar es barato:

* decidir bien es lo caro,  
* y olvidar decisiones es letal.

Este documento deja clara una idea central del *Camino*:

**Las especificaciones no existen para describirlo todo, sino para que lo importante no vuelva a decidirse por azar.**

En el siguiente capítulo abordaremos el siguiente reto inevitable:

¿Qué ocurre cuando, aun con buenas especificaciones, necesitamos regenerar, reescribir o evolucionar grandes partes del sistema sin romperlo todo?  
